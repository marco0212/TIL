## Request Animation Frame

자연스러운 애니메이션을 만드는 것은 많은 요소에 의해 영향을 받는다. 그것은 페이지에서 진행 중인 다른 작업에 따라 다릅니다. 그것은 혹시 병렬적으로 실행 중인 다른 애니메이션일 수 있고, 타이핑이나 클릭하는 등 상호작용 중인 유저일 수 있다.

전통적으로 너는 아마 setInterval이나 그의 우스운 사촌 setTimeout을 애니메이션에 사용하고 있었을지 모른다. 두 함수의 문제는 너무 심플하다는 데 있다. 그들은 브라우저와 작업하는 미묘함과 제 때 페인트하기 위해 얻어야 할 것들에 대해 이해하지 못한다. 그들은 남은 페이지에서 어떻게 진행되어야 하는지에 대한 인지를 가지고 있지 않다. 이런 것들은 애니메이션이 작동할 때 그들을 매우 비효율적으로 만든다. 왜냐하면 그것들은 가끔 브라우저가 페인트나 업데이트를 할 준비가 되어 있지 않을 때 요청한다. 당신은 종종 생략된 프레임과 끔찍한 사이드 이펙트로 애니메이션을 마치게 될 것이다.

만약 setInterval과 setTimeout이 사라진다면 그들은 아마 꽤 조롱할 것이다. setInterval과 setTimeout이 매우 별로임에도 불구하고 당신은 그 외 대체 수단이 없다. 그들을 사용해야 한다. 이러한 대안에 대한 부재가 자바스크립트로 만든 애니메이션이 CSS나 Flash로 만든 것에 비해 덜 우아하게 보인다.

다행히도 Things는 changed됐다. 사이트와 앱을 멋지게 보여주기 위한 애니메이션이 더 중요해짐을 감안해서 주요 브라우저 vendor들은 이 문제를 우아한 방향으로 해결하기 위해 결정했다.
자바스크립트에서 애니메이션을 구현하기 위해 setTimeout이나 setInterval을 사용하는 대신에 그들은 requestAnimationFrame이라는 함수를 만들어냈다.

RequestAnimationFrame을 멋지게 만드는 것은 그것은 브라우저에게 일어나지 않을 것에 대해 repaint를 강요하지 않는다는 것이다. 대신에 브라우저가 화면을 다시 그릴 시간이라고 결정할 때 애니메이션 루프를 호출하도록 브라우저에게 요쳥합니다. 결과적으로 발행하지 않은 화면 업데이트에서 코드로 인해 낭비되는 작업이 없습니다. 건너뛴 프레임은 과거의 일입니다. 무엇보다도 requestAnimationFrame은 애니메이션용으로 설계되었기 때문에 브라우저에서 성능을 최적화하여 사용 가능한 시스템 리소스의 양, 배터리로 실행 중인지 여부, 다른 탭으로 전환하는지 여부, 애니메이션이 원활하게 실행되도록 보장합니다.

그리기 함수를 처음 호출하기 위해 requestAnimationFrame을 사용할 필요는 없습니다. 앞서 몇 섹션에서 animate 메서드를 호출한 것처럼 직접 그리기를 호출할 수도 있습니다. 이를 수행하는 옳고 그른 방법은 없지만 초기 호출에 대해서도 requestAnimationFrame을 사용하면 강제로 즉시 호출되는 대신 브라우저에 그리기 메서드를 호출할 시기를 연기하게 됩니다.

draw 메서드 내에서 이것이 무한 루프를 일으킬 수 있는 것처럼 보이지만 브라우저는 무엇을 해야 하는지 알고 있으며 이와 같은 나쁜 일이 발생하지 않도록 합니다. 그러나 자신의 바닐라 기능으로 이와 같은 것을 시도하지 마십시오.

## Your Frame Rate

지금까지 requestAnimationFrame의 장점과 애니메이션을 정말 부드럽게 만드는 방법을 칭찬했습니다. 매끄럽다는 단어는 실제로 무언가를 측정하는 좋은 방법이 아닙니다. 그것은 조사 아래에 유지되지 않습니다! 부드러움을 측정하는 방법은 프레임 속도라고 하는 매우 친숙한 숫자를 사용하는 것입니다. 프레임 속도가 높을수록 더 좋은 결과를 얻는다는 말을 듣는 영화 감상이나 비디오 게임의 프레임 속도에 이미 익숙할 것입니다. 뭔지 맞춰봐? HTML 세계에서도 마찬가지입니다.

requestAnimationFrame을 사용하는 경우 프레임 속도는 일반적으로 초당 약 60프레임(FPS)입니다. 이를 다르게 반복하려면 requestAnimationFrame 함수 및 관련 코드가 초당 60번 화면을 새로 고칠 가능성이 있음을 의미합니다. 이 번호는 임의로 선택한 것이 아닙니다. 노트북 화면, 컴퓨터 모니터, 전화 디스플레이 등이 물리적으로 화면을 업데이트할 수 있는 속도의 상한선입니다.

> ## Your Frame Rate May Go Lower than 60 FPS
>
> 애니메이션 루프가 매우 복잡하고 많은 작업을 수행하거나 브라우저가 다른 작업으로 가득 차 있는 경우 프레임 속도는 초당 60프레임 미만이 됩니다. 일반적으로 브라우저는 애니메이션을 매우 부드럽게 만들기 위해 올바른 작업을 수행하지만 임의의 속도 저하에 대비합니다

이제 의도적으로 애니메이션 속도를 늦추고 싶을 때가 있습니다. 애니메이션 루프가 초당 60번 호출될 필요가 없을 수도 있습니다. 애니메이션 속도를 조절하려면 다음과 같이 할 수 있습니다

```ts
let framesPerSecond = 10;

function animate() {
  setTimeout(function () {
    requestAnimationFrame(animate);

    // animating/drawing code goes here
  }, 1000 / framesPerSecond);
}
```

setTimeout을 사용하여 다음 requestAnimationFrame 호출이 이루어질 때를 지연하고 있음을 주목하세요. 의도적으로 애니메이션을 10FPS로 느리게 하는 Letter Cycler 예제에서 이 코드가 사용되는 예를 볼 수 있습니다.

## Conclusion

대체로 이것은 꽤 흥미진진합니다. requestAnimationFrame 함수는 CSS에서 생성된 애니메이션 또는 전환과 동일한 수준의 최적화를 테이블에 제공합니다. 귀하의 코드가 브라우저에 화면을 다시 그리도록 지시하고 브라우저(변덕스러운 것)가 해당 요청을 무시하도록 지시하는 대신, requestAnimationFrame은 화면을 다시 그릴 준비가 되었을 때 애니메이션 루프를 호출하도록 브라우저에 정중하게 요청합니다. 이 따뜻한 관계는 정말 부드러운 애니메이션을 만듭니다. 보다! 당신이 자바스크립트 함수라면 친절하게 대해야 합니다!
