# Why is immutability so important in javascript?

**자바스크립트에서 불변성은 왜 중요한가?**

**객체를 수정(mutating)하는 것은 뭐가 문제인가?**

**이것은 직관적이게 하는가?**

불변성의 중요성에 대해 이해하기 전에 소프트웨어 개발에서 가변성과 불변성에 대해 먼저 이해할 필요가 있다.

공주는 잘생긴 왕자님으로 변할 것을 기대하며 개구리에게 뽀뽀를 했다. 불변성의 관점에서 개구리는 언제나 개구리일 뿐이다. 불변성은 함수형 프로그래밍과 객체지향 프로그래밍에서 유래되었다. 데이터를 수정할 때마다 우리는 기존의 것을 수정하는 것이 아닌 항상 새로운 값이 반영된 객체를 얻어야 했다.

불변성은 "save as"로 여길 수 있다. 이 액션을 통해 변화된 새로운 객체를 반환할 것을 기대하기 때문이다. 그에 반해 "save"는 기존의 것에 변화를 반영한다. 불변 데이터는 절대 변경될 수 없다.

객체가 생성되면 그것은 그 자체로 original이 되고 이를 수정할 수 없다. 불변성은 외부에 의해 변화되지 않는 인간의 몸을 예로 들 수 있다.

가변성은 이에 반대되는 개념이다. 가변성은 객체가 선언된 이후 상태를 수정할 수 있는지 여부를 의미한다. 뽀뽀한 개구리가 왕자님이 된 것처럼 말이다. 예를 들어 변수에 값을 할당하고 나중에 변수의 값을 변경하고 객체의 상태가 변화하면 가변한 것으로 간주한다.

불변성에 익숙하지 않은 개발자는 새로운 객체를 다시 할당하는 것에 혼란스러울 수 있다. 자바스크립트에서 문자열과 숫자는 불변성을 지닌 데이터 타입이다.

자바스크립트는 불변성을 유지하기 좋은 언어는 아니다. 이 언어에서 배열과 객체는 변화가 가능하다. 그들의 값은 언제든 변화할 수 있다. 두 데이터 타입 모두 참조값을 전달하며 사용 가능한 대부분의 메서드는 mutate를 유발한다. 아래 예를 보자.

```js
const a = [2, 1, 4, 3];
console.log(a); // [2, 1, 4, 3]

const b = a.sort();

console.log(b); // [1, 2, 3, 4]
console.log(a); // [1, 2, 3, 4]
```

우리는 a라는 변수에 배열을 할당했고 정렬을 수행했다. 정렬된 배열은 b에 할당이 되었고 그 결과 a와 b에 모두 정렬된 배열을 확인할 수 있다. 객체와 배열 모두 복사본이 아닌 참조값을 전달하기 때문에 같은 메모리를 가르켜 정렬 메서드에 의해 직접적으로 operation이 수행되었다.

**많은 배열의 메서드는 mutator이다. copyWithin, fill, pop, push, reverse, shift, sort, splice, unshift 이런 것들이 그러하다. slice, from, map and filter 는 immutator이다. 이것들은 기존의 배열을 수정하지 않고 새로운 배열을 반환하기 때문이다. 객체에서는 Object.assing 메서드가 그러하다.**

객체와 배열을 immutable하게 하기 위해서는 약간의 테크닉이 필요하다. original의 값을 직접적으로 변경하지 마라. 객체를 immutable하게 다루고 전적으로 새로운 객체를 반환하도록 해라.

spread operator는 객체와 배열 모두에서 속성들을 복사해 새로운 값을 만들기에 유용하다. 아래 예를 통해 알아보자.

```js
var daysWorked = [7, 7, 5, 9, 8, 6, 6, 7, 9, 5];

console.log(daysWorked);

//slice for 6 days work
var lastSixMonths = daysWorked.slice(0, 6);
console.log(daysWorked);
console.log(lastSixMonths);

// let's sort the days worked
//mutable object
var sortedDaysWorked = daysWorked.sort();

console.log(sortedDaysWorked);
console.log(daysWorked);

//slice for seven days work
var lastSevenMonths = daysWorked.slice(0, 7);

console.log(lastSevenMonths);
console.log(daysWorked);
```

**자바스크립트에서 불변성의 중요성**

**불변성의 이점은 무엇인가? 왜 우리는 귀찮은 불변성에 관심을 두어야 하는가?**

불변성은 데이터를 엄격하게 제어하여 코드를 안전하고 예측 가능하게 만든다. In other words, 불변 객체를 사용하면 예측 가능한 방식으로 데이터 흐름을 제어하며 변경 사항을 효율적으로 발견할 수 있다. 이것은 또한 undo/redo 와 같은 복잡한 기능도 수월하게 만들 수 있게 하고 time travel debugging이나 업데이트, 롤백을 최적화 하는데도 사용될 수 있다.

만약 프론트에서 Redux와 같은 라이브러리를 사용한다면 불변성은 이전 상태와 이후 상태를 빠르고 덜 소모적이게 비교함으로서 더 좋은 성능을 기대할 수도 있다.

불변성을 유지했을 때 가장 큰 이점은 예측 가능성, 성능(performance), better mutation 추적 등이 있다.

1. 예측 가능성

일반적으로 프론트엔드 라이브러리를 사용할 때 우린 많은 상태를 선언한다. 우리는 비동기적인 액션을 수행하도록 하고 original 상태를 업데이트한다. 사용자가 웹 어플리케이션을 사용하기 시작하면 상태는 초기와 차이가 생긴다. 변경되는 상태는 숨겨지고 이것은 다른 부수 효과를 발생 시키며 이를 디버깅하는 것은 어렵다.

만약 앱의 설계를 immutable하게 구성한다면 상태가 더 예측하기 쉬워지며 의도치 않은 부수 효과가 없을 것임에 안심할 수 있다.

2. 불변 객체를 유지하는 것은 많은 메모리를 소모한다. 왜일까? 만약 객체에 새로운 값을 추가한다고 하면 우리는 새로운 객체에 기존 값들을 복사하여 새롭게 만들어야 한다. 이를 수행하기 위해서는 추가적인 메모리를 필요로 한다. 이런 메모리 소모를 방지하기 위해 우리는 structural sharing을 활용한다.

업데이트가 새로운 값을 생성할 때마다 우리는 구조를 공유하여 메모리 소모를 방지할 수 있다. 예를 들어 100개의 요소를 가지고 있는 객체에 값을 추가하면 101개의 요소 길이의 객체를 생성하지 않는다. 다만 소수의 작은 요소를 내부적으로 할당한다.

3. Mutation Tracking

불변성의 이점 중 하나는 참조값과 value를 같게 만듦으로서 최적화를 이룰 수 있는 것이다. 이것은 어떤 것이 바뀌었는지 식별하기 편리하게 만든다. 예를 들어 React에서 Component의 Prop이 변경되었을 때. ShouldComponentUpdate는 상태 객체를 비교하여 상태가 동일한지 확인하고 불필요한 렌더링을 방지하는데 사용할 수 있다.

불변성은 이벤트 체인과 같은 객체에 변화가 발생했을 때 추적할 수 있도록 도와준다. 새로운 참조값을 할당한 변수를 이전의 값과 비교하는 것은 매우 쉽다. 이것은 동시성 어플리케이션에서 디버깅하기 수월함을 제공한다. 또한 이벤트 디버거는 reply DOM events 같은 기능을 통해 디버깅을 하게끔 한다.

불변성이 처음이라면 아마 혼란스러울 수 있다. 만약 불변성의 이점을 파악한다면 더 좋게 만들 수 있다. 상태를 변경하여 많은 에러에 시달릴 때 이것은 보다 좋은 방향으로 이끌 수 있다.
